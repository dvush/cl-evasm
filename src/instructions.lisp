(in-package #:cl-evasm)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *list-mnemonics* (make-hash-table))
  (defvar *atom-mnemonics* (make-hash-table)))

(defclass instruction () ())

(defmacro instruction-class-from-mnemonics (mnemonic bytecode stack-effect)
  (cond ((symbolp mnemonic)
	 (let ((class-name (alexandria:symbolicate mnemonic '-evm)))
	   (assert (typep bytecode '(unsigned-byte 8)) () "Bytecode should be byte value for simple mnemonics")


	   `(progn
	      (defclass ,class-name (instruction) ())
	      (setf (gethash (quote ,mnemonic) *atom-mnemonics*) (lambda () (make-instance (quote ,class-name))))
	      (defmethod to-bytecode ((ins ,class-name))
		(bitsmash:octets<- ,bytecode))
	      (defmethod stack-effect ((ins ,class-name))
		(list ,@stack-effect)))
	   ))
	((listp mnemonic)
	 (let* ((head (car mnemonic))
		(args (cdr mnemonic))
		(class-name (alexandria:symbolicate head '-evm)))
	   `(progn
		(defclass ,class-name (instruction)
		  ,(loop for arg in args collect (list arg :initarg (alexandria:make-keyword arg)
						       :accessor (alexandria:symbolicate 'get- arg))))
		(setf (gethash (quote ,head) *list-mnemonics*)
		      (lambda ,args (make-instance (quote ,class-name)
						   ,@(loop for arg in args
							   append (list (alexandria:make-keyword arg) arg)))))
		(defmethod to-bytecode ((ins ,class-name))
		  (with-slots ,args ins
		    (bitsmash:octets<- ,bytecode)))
		(defmethod stack-effect ((ins ,class-name))
		  (with-slots ,args ins
		    (list ,@stack-effect))))))
	(t (error "mnemonic is not supported"))))

(defmacro instruction-classes-from-mnemonics (&rest mnemonic-definitions)
  `(progn
     ,@(loop for mnem in mnemonic-definitions
	   collect `(instruction-class-from-mnemonics ,@mnem))))

(instruction-classes-from-mnemonics
 (stop #x00 (0 0))
 (add #x01 (2 1))
 (mul #x02 (2 1))
 (sub #x03 (2 1))
 (div #x04 (2 1))
 (sdiv #x05 (2 1))
 (mod #x06 (2 1))
 (smod #x07 (2 1))
 (addmod #x08 (3 1))
 (mulmod #x09 (3 1))
 (exp #x0a (2 1))
 (signextend #x0b (2 1))
 (lt #x10 (2 1))
 (gt #x11 (2 1))
 (slt #x12 (2 1))
 (sgt #x13 (2 1))
 (eq #x14 (2 1))
 (iszero #x15 (1 1))
 (and #x16 (2 1))
 (or #x17 (2 1))
 (xor #x18 (2 1))
 (not #x19 (2 1))
 (byte #x1a (2 1))
 (shl #x1b (2 1))
 (shr #x1c (2 1))
 (sar #x1d (2 1))
 (sha3 #x20 (2 1))
 (address #x30 (0 1))
 (balance #x31 (0 1))
 (origin #x32 (0 1))
 (caller #x33 (0 1))
 (callvalue #x34 (0 1))
 (calldataload #x35 (1 1))
 (calldatasize #x36 (0 1))
 (calldatadopy #x37 (3 0))
 (codesize #x38 (0 1))
 (codecopy #x39 (3 0))
 (gasprice #x3a (0 1))
 (extcodesize #x3b (1 1))
 (extcodecopy #x3c (4 0))
 (returndatasize #x3d (0 1))
 (returndatacopy #x3e (3 0))
 (extcodehash #x3f (1 1))
 (blockhash #x40 (1 1))
 (coinbase #x41 (0 1))
 (timestamp #x42 (0 1))
 (number #x43 (0 1))
 (difficulty #x44 (0 1))
 (gaslimit #x45 (0 1))
 (chaind #x46 (0 1))
 (selfbanace #x47 (0 1))
 (basefee #x48 (0 1))
 (pop #x50 (1 0))
 (mload #x51 (1 1))
 (mstore #x52 (2 0))
 (mstore8 #x53 (2 0))
 (sload #x54 (1 1))
 (sstore #x55 (2 0))
 (jump #x56 (1 0))
 (jumpi #x57 (2 0))
 (pc #x58 (0 1))
 (msize #x59 (0 1))
 (gas #x5a (0 1))
 (jumpdest #x5b (0 0))
 ((push n data)
  (let ((octets (bitsmash:octets<- data)))
    (when (> (length octets) n)
      (error "push data length is bigger than push n"))
    (concatenate '(vector (unsigned-byte 8))
		 (list (+ #x60 (1- n)))
		 (make-array (- n (length octets)) :initial-element 0)
		 octets))
  (0 1))
 ((dup n) (+ #x80 (1- n)) (n (1+ n)))
 ((swap n) (+ #x90 (1- n)) (n n))
 ((log n) (+ #xa0 (1- n)) ((+ 2 n) 0))
 (create #xf0 (3 1))
 (call #xf1 (7 1))
 (callcode #xf2 (7 1))
 (return #xf3 (2 0))
 (delegatecall #xf4 (6 1))
 (create2 #xf5 (4 1))
 (staticcall #xfa (6 1))
 (revert #xfd (2 0))
 ((invalid data) (bitsmash:octets<- data) (0 0))
 ((push-label sym) (error "labels should be resolved") (0 1))
 ((label sym) (error "labels should be resolved") (0 0))
 (selfdestuct #xff (1 0)))


(defmethod print-object ((obj push-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (n data) obj
          (format stream "~a ~a" n (bitsmash:hex<- (subseq  (to-bytecode obj) 1))))))
(defmethod print-object ((obj invalid-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (data) obj
          (format stream "~a" (bitsmash:hex<- (to-bytecode obj))))))
(defmethod print-object ((obj dup-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (n) obj
          (format stream "~a" n))))
(defmethod print-object ((obj swap-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (n) obj
          (format stream "~a" n))))
(defmethod print-object ((obj log-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (n) obj
          (format stream "~a" n))))
(defmethod print-object ((obj push-label-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (sym) obj
          (format stream "~a" sym))))
(defmethod print-object ((obj label-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (sym) obj
          (format stream "~a" sym))))
(defmethod print-object ((obj add-evm) stream)
      (print-unreadable-object (obj stream :type t)
	(format stream "")))
