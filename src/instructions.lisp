(in-package #:cl-evasm)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *list-mnemonics* (make-hash-table))
  (defvar *atom-mnemonics* (make-hash-table)))

(defclass instruction () ())

(defmacro instruction-class-from-mnemonics (mnemonic bytecode)
  (cond ((symbolp mnemonic)
	 (let ((class-name (alexandria:symbolicate mnemonic '-evm)))
	   (assert (typep bytecode '(unsigned-byte 8)) () "Bytecode should be byte value for simple mnemonics")


	   `(progn
	      (defclass ,class-name (instruction) ())
	      (setf (gethash (quote ,mnemonic) *atom-mnemonics*) (lambda () (make-instance (quote ,class-name))))
	      (defmethod to-bytecode ((ins ,class-name))
		(bitsmash:octets<- ,bytecode)))
	   ))
	((listp mnemonic)
	 (let* ((head (car mnemonic))
		(args (cdr mnemonic))
		(class-name (alexandria:symbolicate head '-evm)))
	   `(progn
		(defclass ,class-name (instruction)
		  ,(loop for arg in args collect (list arg :initarg (alexandria:make-keyword arg)
						       :accessor (alexandria:symbolicate 'get- arg))))
		(setf (gethash (quote ,head) *list-mnemonics*)
		      (lambda ,args (make-instance (quote ,class-name)
						   ,@(loop for arg in args
							   append (list (alexandria:make-keyword arg) arg)))))
		(defmethod to-bytecode ((ins ,class-name))
		  (with-slots ,args ins
		    (bitsmash:octets<- ,bytecode))))))
	(t (error "mnemonic is not supported"))))

(defmacro instruction-classes-from-mnemonics (&rest mnemonic-definitions)
  `(progn
     ,@(loop for mnem in mnemonic-definitions
	   collect `(instruction-class-from-mnemonics ,(first mnem) ,(second mnem)))))

(instruction-classes-from-mnemonics
 (stop #x00)
 (add #x01)
 (mul #x02)
 (sub #x03)
 (div #x04)
 (sdiv #x05)
 (mod #x06)
 (smod #x07)
 (addmod #x08)
 (exp #x0a)
 (signextend #x0b)
 (lt #x10)
 (gt #x11)
 (slt #x12)
 (sgt #x13)
 (eq #x14)
 (iszero #x15)
 (and #x16)
 (or #x17)
 (xor #x18)
 (not #x19)
 (byte #x1a)
 (shl #x1b)
 (shr #x1c)
 (sar #x1d)
 (sha3 #x20)
 (address #x30)
 (balance #x31)
 (origin #x32)
 (caller #x33)
 (callvalue #x34)
 (calldataload #x35)
 (calldatasize #x36)
 (calldatadopy #x37)
 (codesize #x38)
 (codecopy #x39)
 (gasprice #x3a)
 (extcodesize #x3b)
 (extcodecopy #x3c)
 (returndatasize #x3d)
 (returndatacopy #x3e)
 (extcodehash #x3f)
 (blockhash #x40)
 (coinbase #x41)
 (timestamp #x42)
 (number #x43)
 (difficulty #x44)
 (gaslimit #x45)
 (chaind #x46)
 (selfbanace #x47)
 (basefee #x48)
 (pop #x50)
 (mload #x51)
 (mstore #x52)
 (mstore8 #x53)
 (sload #x54)
 (sstore #x55)
 (jump #x56)
 (jumpi #x57)
 (pc #x58)
 (msize #x59)
 (gas #x5a)
 (jumpdest #x5b)
 ((push n data) (let ((octets (bitsmash:octets<- data)))
		  (when (> (length octets) n)
		    (error "push data length is bigger than push n"))
		  (concatenate '(vector (unsigned-byte 8))
			       (list (+ #x60 (1- n)))
			       (make-array (- n (length octets)) :initial-element 0)
			       octets)))
 ((dup n) (+ #x80 (1- n)))
 ((swap n) (+ #x90 (1- n)))
 ((log n) (+ #xa0 (1- n)))
 (create #xf0)
 (call #xf1)
 (callcode #xf2)
 (return #xf3)
 (delegatecall #xf4)
 (create2 #xf5)
 (staticcall #xfa)
 (revert #xfd)
 ((invalid data) (bitsmash:octets<- data))
 ((push-label sym) (error "labels should be resolved"))
 ((label sym) (error "labels should be resolved"))
 (selfdestuct #xff))


(defmethod print-object ((obj push-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (n data) obj
          (format stream "~a ~a" n (bitsmash:hex<- (subseq  (to-bytecode obj) 1))))))
(defmethod print-object ((obj invalid-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (data) obj
          (format stream "~a" (bitsmash:hex<- (to-bytecode obj))))))
(defmethod print-object ((obj dup-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (n) obj
          (format stream "~a" n))))
(defmethod print-object ((obj swap-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (n) obj
          (format stream "~a" n))))
(defmethod print-object ((obj log-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (n) obj
          (format stream "~a" n))))
(defmethod print-object ((obj push-label-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (sym) obj
          (format stream "~a" sym))))
(defmethod print-object ((obj label-evm) stream)
      (print-unreadable-object (obj stream :type t)
        (with-slots (sym) obj
          (format stream "~a" sym))))
(defmethod print-object ((obj add-evm) stream)
      (print-unreadable-object (obj stream :type t)
	(format stream "")))
