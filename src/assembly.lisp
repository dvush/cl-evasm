(in-package #:evasm)

(defparameter *jump-dest-size-bytes* 2)
(defparameter +max-uint+ (1- (expt 2 256)))


(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *mnemonics-symbol-checks* (make-hash-table))
  (defvar *mnemonics-list-checks* (make-hash-table))
  (defvar *mnemonics-to-bytecode* (make-hash-table))
  (defvar *mnemonics-to-stackeffect* (make-hash-table)))

(defmacro def-evasm-mnemonic (mnemonic bytecode-form stack-effect-form &key validate)
  (let ((mnemonic-symbol-p (symbolp mnemonic))
	(mnemonic-name (alexandria:ensure-car mnemonic))
	(mnemonic-args (cdr (alexandria:ensure-list mnemonic))))
    `(progn
       (setf (gethash (quote ,mnemonic-name) ,(if mnemonic-symbol-p '*mnemonics-symbol-checks* '*mnemonics-list-checks*))
	     (lambda (&rest check-args)
	       (and (= (length check-args) ,(1+ (length mnemonic-args)))
		    (eql (car check-args) (quote ,mnemonic-name))
		    ,@(when validate
			(list
			 `(destructuring-bind ,mnemonic-args (cdr check-args)
			    (declare (ignorable ,@mnemonic-args))
			    ,validate))))))
       (setf (gethash (quote ,mnemonic-name) *mnemonics-to-bytecode*)
	     (lambda (mnemonic ,@mnemonic-args)
	       (declare (ignorable ,@mnemonic-args))
	       (assert (eq mnemonic (quote ,mnemonic-name)) ())
	       ,(when validate
		  `(assert ,validate ()))
	       (bitsmash:octets<- ,bytecode-form)))
       (setf (gethash (quote ,mnemonic-name) *mnemonics-to-stackeffect*)
	     (lambda (mnemonic ,@mnemonic-args)
	       (declare (ignorable ,@mnemonic-args))
	       (assert (eq mnemonic (quote ,mnemonic-name)) ())
	       ,(when validate
		  `(assert ,validate ()))
	       ,stack-effect-form)))))

(defmacro def-evasm-mnemonics (&rest mnemonic-definitions)
  `(progn
     ,@(loop for mnem in mnemonic-definitions
	     collect `(def-evasm-mnemonic ,@mnem))))


(def-evasm-mnemonics
    (stop #x00 '(0 0))
    (add #x01 '(2 1))
  (mul #x02 '(2 1))
  (sub #x03 '(2 1))
  (div #x04 '(2 1))
  (sdiv #x05 '(2 1))
  (mod #x06 '(2 1))
  (smod #x07 '(2 1))
  (addmod #x08 '(3 1))
  (mulmod #x09 '(3 1))
  (exp #x0a '(2 1))
  (signextend #x0b '(2 1))
  (lt #x10 '(2 1))
  (gt #x11 '(2 1))
  (slt #x12 '(2 1))
  (sgt #x13 '(2 1))
  (eq #x14 '(2 1))
  (iszero #x15 '(1 1))
  (and #x16 '(2 1))
  (or #x17 '(2 1))
  (xor #x18 '(2 1))
  (not #x19 '(2 1))
  (byte #x1a '(2 1))
  (shl #x1b '(2 1))
  (shr #x1c '(2 1))
  (sar #x1d '(2 1))
  (sha3 #x20 '(2 1))
  (address #x30 '(0 1))
  (balance #x31 '(0 1))
  (origin #x32 '(0 1))
  (caller #x33 '(0 1))
  (callvalue #x34 '(0 1))
  (calldataload #x35 '(1 1))
  (calldatasize #x36 '(0 1))
  (calldatadopy #x37 '(3 0))
  (codesize #x38 '(0 1))
  (codecopy #x39 '(3 0))
  (gasprice #x3a '(0 1))
  (extcodesize #x3b '(1 1))
  (extcodecopy #x3c '(4 0))
  (returndatasize #x3d '(0 1))
  (returndatacopy #x3e '(3 0))
  (extcodehash #x3f '(1 1))
  (blockhash #x40 '(1 1))
  (coinbase #x41 '(0 1))
  (timestamp #x42 '(0 1))
  (number #x43 '(0 1))
  (difficulty #x44 '(0 1))
  (gaslimit #x45 '(0 1))
  (chaind #x46 '(0 1))
  (selfbanace #x47 '(0 1))
  (basefee #x48 '(0 1))
  (pop #x50 '(1 0))
  (mload #x51 '(1 1))
  (mstore #x52 '(2 0))
  (mstore8 #x53 '(2 0))
  (sload #x54 '(1 1))
  (sstore #x55 '(2 0))
  (jump #x56 '(1 0))
  (jumpi #x57 '(2 0))
  (pc #x58 '(0 1))
  (msize #x59 '(0 1))
  (gas #x5a '(0 1))
  (jumpdest #x5b '(0 0))
  ((push n data)
   (let ((octets (bitsmash:octets<- data)))
     (when (> (length octets) n)
       (error "push data length is bigger than push n"))
     (concatenate '(vector (unsigned-byte 8))
		  (list (+ #x60 (1- n)))
		  (make-array (- n (length octets)) :initial-element 0)
		  octets))
   '(0 1) :validate (<= 1 n 32))
  ((dup n) (+ #x80 (1- n)) (list n (1+ n)) :validate (<= 1 n 16))
  ((swap n) (+ #x90 (1- n)) (list n n)  :validate (<= 1 n 16))
  ((log n) (+ #xa0 n) (list (+ 2 n) 0) :validate (<= 0 n 4))
  (create #xf0 '(3 1))
  (call #xf1 '(7 1))
  (callcode #xf2 '(7 1))
  (return #xf3 '(2 0))
  (delegatecall #xf4 '(6 1))
  (create2 #xf5 '(4 1))
  (staticcall #xfa '(6 1))
  (revert #xfd '(2 0))
  ((verbatim data) (bitsmash:octets<- data) '(0 0))
  (invalid #xfe '(0 0))
  ((push-label sym) (error "labels should be resolved") '(0 1))
  ((label sym) (error "labels should be resolved") '(0 0))
  (selfdestuct #xff '(1 0)))

(defun integer-to-push (int)
  (assert (<= 0 int +max-uint+) (int))
  (let ((bytes-needed (max (ceiling (integer-length int) 8)
			   1)))
    (list 'push bytes-needed int)))

(defun string-to-push (string)
  (let ((string (if (and (>= (length string) 2)
			 (string= "0x" (subseq string 0 2)))
		    (subseq string 2)
		    string)))
    (integer-to-push (bitsmash:hex->int string))))

(defun asm-raw (ins)
  (cond ((typep ins 'integer) (list (integer-to-push ins)))
	((stringp ins) (list (string-to-push ins)))
	((symbolp ins) (multiple-value-bind (mnemonic-check-fun found) (gethash ins *mnemonics-symbol-checks*)
			 (assert (and found
				      (apply mnemonic-check-fun (list ins)))
				 () "Incorrect asm symbol mnemonic: ~a" ins)
			 (list ins)))
	((listp ins)
	 (multiple-value-bind (mnemonic-check-fun found) (gethash (car ins) *mnemonics-list-checks*)
	   (if found
	       (progn
		 (assert (apply mnemonic-check-fun ins) () "Incorrect asm list symbol mnemonic: ~a" ins)
		 (list ins))
	       (loop for i in ins append (asm-raw i)))))
	(t (error "Incorrect assembly instruction ~a" ins))))

(defmacro asm (&rest ins)
  `(asm-raw
    (list
     ,@(loop for i in ins
	     collect
		(cond ((gethash i *mnemonics-symbol-checks*) `(quote ,i))
		      ((and (listp i) (gethash (car i) *mnemonics-list-checks*))
		       `(list (quote ,(car i)) ,@(cdr i)))
		      (t `(asm-raw (list ,i))))))))

(defmacro asm-oct (&rest ins)
  `(mnemonics->octets (asm ,@ins)))

(defmacro asm-hex (&rest ins)
  `(mnemonics->hex (asm ,@ins)))

(defun instruction-to-bytecode (ins)
  (let ((ins-name (alexandria:ensure-car ins)))
    (multiple-value-bind (to-bytecode-fun found) (gethash ins-name *mnemonics-to-bytecode*)
      (assert found (ins) "Incorrect instruction")
      (apply to-bytecode-fun (alexandria:ensure-list ins)))))

(defun resolve-jumplabels (asm)
  (let ((label-positions (make-hash-table)))
    (let ((offset 0))
      (dolist (ins asm)
	(when (eql (alexandria:ensure-car ins) 'label)
	  (assert (null (gethash (second ins) label-positions)) ()
		  "Jump label occurs multiple times: ~a" (second ins))
	  (setf (gethash (second ins) label-positions) offset))
	(let ((ins-length (trivia:match ins
			    ((list 'push-label _) (1+ *jump-dest-size-bytes*))
			    ((list 'label _) 1)
			    (_ (length (instruction-to-bytecode ins))))))
	  (setf offset (+ offset ins-length)))))
    (loop for ins in asm
	  collect (trivia:match ins
		    ((list 'push-label label) (let ((label-pos (gethash label label-positions)))
						(unless label-pos
						  (error "Jumplabel can't be resolved ~a" label))
						(list 'push *jump-dest-size-bytes* label-pos)))
		    ((list 'label _) 'jumpdest)
		    (other other)))))

(defun mnemonics->octets (asm)
  (let ((asm (resolve-jumplabels asm)))
    (apply #'concatenate '(vector (unsigned-byte 8))
	   (loop for ins in asm
		 collect (instruction-to-bytecode ins)))))


(defun mnemonics->hex (asm)
  (bitsmash:hex<- (mnemonics->octets asm)))
